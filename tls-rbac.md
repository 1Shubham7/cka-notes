dFirstly, how the website and server communicate:

![image](https://github.com/user-attachments/assets/efa1526a-ea74-4ff8-a2af-d3798e2496a8)

To explain in detail:

## 1. DNS Resolution
## 2. Establish a TCP Connection
![image](https://github.com/user-attachments/assets/698428bd-b367-42ba-ac46-c82ddd52c6fa)

(Example I have taken of Google.com)

- Browser sends a synchronization (SYN) packet to the server.
- Google’s server responds with a synchronization-acknowledgment (SYN-ACK) packet.
- Browser acknowledges with an ACK packet.
and the TCP connection is established, this is called TCP handshake (don't confuse it with TLS handshake).

## 3. Initiate the TLS Handshake
![image](https://github.com/user-attachments/assets/c6f70f31-01fe-4ef0-afd7-dfab5b06d7c6)

1. **Client Hello:** The client sends a ClientHello message to initiate the handshake.
The message includes Client random, A random value generated by the client.

2. **ServerHello:** The server responds with a ServerHello message. it contains Server random, A random value generated by the server.

3. **Certificate Transmission:** After the ServerHello, the server sends the Certificate. The certificate contains the server's public key and is signed by a trusted Certificate Authority (CA).
The server may also include a CertificateVerify message to prove that it owns the private key corresponding to the certificate.

CA Verification Process (Client-Side):

- The client verifies that the certificate was issued by a trusted CA.
- Ensure the certificate is valid for the requested domain (matches the hostname).
- Check the certificate’s validity period (not expired).
- The client ensures that the CA's signature on the certificate is valid (using the CA's public key).

4. Finished Messages
Both the client and server send a Finished message. This message includes a hash of all the handshake messages exchanged so far, encrypted with the derived session key (session key is derived by client and server together). It ensures the integrity of the handshake process and proves that both sides have derived the same session key.

6. Secure Communication
the handshake is complete and all further communication between the client and server is encrypted using the session key.

6. Communication is encrypted, now you can send HTTP req.

## In K8s

In K8s the api server will become both a client and a server:

![image](https://github.com/user-attachments/assets/b72acf84-c977-46ec-be61-d1787dfffb1e)

In Kubernetes, communication between these components also encrypted via CA certificates:

![image](https://github.com/user-attachments/assets/5cd1213a-7286-40f9-b0d8-3f628d915ff3)

**Public Key:** tells who you are
**Private Key:** proves who you are + decryption

- if the key has the term "key" in it, it is a private key, else it is a public key:

![image](https://github.com/user-attachments/assets/5d21220d-9550-4102-a3c6-976a975eb7a7)

- all the certificates in K8s are stored at `/etc/kubernetes/pki`

To create certificate for a user, go to kubernetes docs, type certificate and go to link (Certificates and Certificate Signing Requests | Kubernetes) and search "How to issue a certificate for a user".


![image](https://github.com/user-attachments/assets/fd390f7a-2abf-4312-9689-a7f51e4cd5a6)

This was the authentication part, now the authorization part:

` k auth whoami`
` k auth can-i get pods`

>> if they ask you to count the number of roles or anything else: `k get roles -A --no-headers | wc -l`
- wc stands for word count. `wc -l` Counts the number of lines in the input.

```
k config  set-credentials Shubham \
> --client-certificate=shubham.crt \
> --client-key=shubham.key \
> --embed-certs=true
```

--embed-certs=true is used because:
The actual contents of the client certificate and key files are embedded directly into the kubeconfig file. otherwise The kubeconfig file will only contain references (paths) to the shubham.csr and shubham.key files.

// Roles and RoleBindings are namespace scoped so if question needs cluster scoped, use cluster Role and cluster Binding.

For service accounts this file is very important: `/var/run/secrets/kubernetes.io/serviceaccount/` because it contains:
- ca.crt: The CA certificate for the Kubernetes API server.
- token: The token (JWT) used for authenticating the Pod with the Kubernetes API.
- namespace: The namespace in which the Pod is running.

```
openssl x509 -in <certificate-file> -text -noout
```
Learn this command:
-text → Displays the certificate details in human-readable form.
-noout → Suppresses the output of the actual certificate.

(more about this in the video)

## Security Contexts

security applied in container will override what you apply at pod level. 

![image](https://github.com/user-attachments/assets/f0f09cfc-df33-4665-8ab5-aad940d5718a)



[MAC_ADMIN] is a persmission. and that `runAsUser` means all processes inside the container will run as the user with UID 1000 instead of the default root user (UID 0). everything is in docs.

If they ask you to run as root, write nothing, root is default.
