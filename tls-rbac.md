Firstly, how the website and server communicate:

![image](https://github.com/user-attachments/assets/efa1526a-ea74-4ff8-a2af-d3798e2496a8)

To explain in detail:

## 1. DNS Resolution
## 2. Establish a TCP Connection
![image](https://github.com/user-attachments/assets/698428bd-b367-42ba-ac46-c82ddd52c6fa)

(Example I have taken of Google.com)

- Browser sends a synchronization (SYN) packet to the server.
- Google’s server responds with a synchronization-acknowledgment (SYN-ACK) packet.
- Browser acknowledges with an ACK packet.
and the TCP connection is established, this is called TCP handshake (don't confuse it with TLS handshake).

## 3. Initiate the TLS Handshake
![image](https://github.com/user-attachments/assets/c6f70f31-01fe-4ef0-afd7-dfab5b06d7c6)

1. **Client Hello:** The client sends a ClientHello message to initiate the handshake.
The message includes Client random, A random value generated by the client.

2. **ServerHello:** The server responds with a ServerHello message. it contains Server random, A random value generated by the server.

3. **Certificate Transmission:** After the ServerHello, the server sends the Certificate. The certificate contains the server's public key and is signed by a trusted Certificate Authority (CA).
The server may also include a CertificateVerify message to prove that it owns the private key corresponding to the certificate.

CA Verification Process (Client-Side):

- The client verifies that the certificate was issued by a trusted CA.
- Ensure the certificate is valid for the requested domain (matches the hostname).
- Check the certificate’s validity period (not expired).
- The client ensures that the CA's signature on the certificate is valid (using the CA's public key).

4. Finished Messages
Both the client and server send a Finished message. This message includes a hash of all the handshake messages exchanged so far, encrypted with the derived session key (session key is derived by client and server together). It ensures the integrity of the handshake process and proves that both sides have derived the same session key.

6. Secure Communication
the handshake is complete and all further communication between the client and server is encrypted using the session key.

6. Communication is encrypted, now you can send HTTP req.

## In K8s

In K8s the api server will become both a client and a server:

![image](https://github.com/user-attachments/assets/b72acf84-c977-46ec-be61-d1787dfffb1e)

In Kubernetes, communication between these components also encrypted via CA certificates:

![image](https://github.com/user-attachments/assets/5cd1213a-7286-40f9-b0d8-3f628d915ff3)

**Public Key:** tells who you are
**Private Key:** proves who you are + decryption

- if the key has the term "key" in it, it is a private key, else it is a public key:

![image](https://github.com/user-attachments/assets/5d21220d-9550-4102-a3c6-976a975eb7a7)

- all the certificates in K8s are stored at `/etc/kubernetes/pki`

To create certificate for a user, go to kubernetes docs, type sertificate and go to third link (Certificates and Certificate Signing Requests | Kubernetes) and search "How to issue a certificate for a user".

Step 1. consider we are a user called dolly, dolly want to get access as a cluster admin, so he will create a private key:
`openssl genrsa -out shubham.key 2048`

and then use this to create a CSR:
`openssl req -new -key shubham.key -out shubham.csr -subj "/CN=shubham"`

Step 2. Now, we as cluster admin will now ask for his CSR only, and then create a csr.yaml, in that csr.yaml in request field we will use base64 encoded version of his CSR:
`cat shubham.csr | base64 | tr -d "\n"`  (it command base64 encodes the file and removes spaces to give a single string)

Step 3. just create a kubernetes CSR by `kubectl apply -f csr.yaml`, now we have a CSR in our cluster. this CSR is authorized by a public CA authority, since we are using this for a internal server and not a website as such, our CA is on control plane.

you can approve the CSR by `k certificate approve Shubham`. if we have the required role to approve, the CSR will be approved. now share that CSR with dolly:

`k get csr Shubham -o yaml > issuecert.yaml`

in  this issuecert, you will find certificate field, simply decode it:

```sh
 echo "LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUM5ekNDQWQrZ0F3SUJBZ0lRSFhENk9JSWZwZHROV284T0t0NXBYREFOQmdrcWhraUc5dzBCQVFzRkFEQVYKTVJNd0VRWURWUVFERXdwcmRXSmxjbTVsZEdWek1CNFhEVEkxTURFeU56QTRNRFl5T1ZvWERUSTFNREV5T0RBNApNRFl5T1Zvd0VqRVFNQTRHQTFVRUF4TUhjMmgxWW1oaGJUQ0NBU0l3RFFZSktvWklodmNOQVFFQkJRQURnZ0VQCkFEQ0NBUW9DZ2dFQkFPc1QyMElEaTJBYmEwc3orZHFwUXJjb0pxZEdJdzZzN01IUW5VcklsemNCZkZmSmI0a0wKazh1dk1KaHUzYjdvOS9uWkFYNXJiUnhZNTN5bmZzaXI4amk5Y3dBZHF6M2VHU2Z3eVlLT0pFd3cwaDFLcXJ1cwoxQXJUeThORTI4bDdpYVBIYkRzOWlsa01mMEgxN0VsSHJtUGIrZnRkODhLbCt3aXNqd3l2YmFjdGlpZEF0RnhNCnMwbEsxbGNWZjFkcDUvSHZRNnFCTmdKa0xDbGcxMkFHRnpWNi9STHMzMEU1dWFaQ1lqQUZJci82RDNNRTNmT0MKMTFXTGVEUDBvdi9RSDdkWlAyR240aFNZVGJUSlJMcTRHSHFqeFkyY0JLQWNIa1VmNlBFdnhlNWJzaFNwS3VNTgpIUDJHUWEramp6bnp2SFc1Q005L2hOUXVrTEVLZnBMd1Q0c0NBd0VBQWFOR01FUXdFd1lEVlIwbEJBd3dDZ1lJCkt3WUJCUVVIQXdJd0RBWURWUjBUQVFIL0JBSXdBREFmQmdOVkhTTUVHREFXZ0JSUzkyWjVRSUcvblp3ZHp6NXgKdDZrOTlpcDZVakFOQmdrcWhraUc5dzBCQVFzRkFBT0NBUUVBazZPeFN0b3hGaE8yeDBwZWdiZnZEVGZxeU03Nwp3bUVobllLREhtQkp4TE9jbUN3blplLytLSzRkSUpHemxSamVibGFCT1ZLUy93YzY2WWV3S1k1VzRXRVkvblNQCkU3dkRhTW1ONjhTdUJ5eGZVeVk3SUYzNzRRSTFBTXJ0dCtjMjVtT0tkTmdjbG50Y0ZyNzBxM1M0a1o3NC9XRmcKTWxDUUdaalhpN1dEYlAzM1FoU1pMLzE3Y2JaRkRBUEUzL3U0ZDluZ1IwdlRNemoxVlhwYTVGSlF0bXAzeEVTaApOY1cvUHltRFVlSVFiL3RBREFCL2VwVEQxYjJMd2ZIeEpjbTBqZHJVYkh4TUdaVmZFa3ZFTnd4Tm1JZ0wyWHNTCmk1dkdCckxsTVBNSW9XcUF5T2MzU3p4d1UySHkyZ0E4REFLdzJkL2h6OGxzL1pybkFmemdjK1IxNHc9PQotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg==" | base64 -d
```

// You can find the kubeconfig file is `.kube` folder in home dir.

![image](https://github.com/user-attachments/assets/fd390f7a-2abf-4312-9689-a7f51e4cd5a6)

This was the authentication part, now the authorization part:

` k auth whoami`
` k auth can-i get pods`

>> if they ask you to count the number of roles or anything else: `k get roles -A --no-headers | wc -l`
- wc stands for word count. `wc -l` Counts the number of lines in the input.

Step 4.

